{
	"meta": {
		"generatedAt": "2025-10-31T13:25:23.781Z",
		"tasksAnalyzed": 5,
		"totalTasks": 22,
		"analysisCount": 5,
		"thresholdScore": 5,
		"projectName": "Taskmaster",
		"usedResearch": true
	},
	"complexityAnalysis": [
		{
			"taskId": 18,
			"taskTitle": "Fix Race Condition in GitHubSyncStateService File Lock Implementation",
			"complexityScore": 8,
			"recommendedSubtasks": 5,
			"expansionPrompt": "Outline subtasks that cover designing a reusable async mutex utility with timeouts/reentrancy, refactoring both `GitHubSyncStateService` and the file-storage adapter to adopt it, adding targeted concurrency tests (unit + integration), and validating logging/backward-compatibility.",
			"reasoning": "`GitHubSyncStateService` still relies on a `Map<string, Promise<void>>` lock map (`packages/tm-core/src/modules/integration/services/github-sync-state.service.ts:150`) across three write paths (`saveState`, `modifyState`, `saveStateWithoutBackup` around lines 794-1036), and `FileOperations` repeats the same pattern (`packages/tm-core/src/modules/storage/adapters/file-storage/file-operations.ts:13`). Replacing this with a queued mutex that supports timeouts and reentrancy requires building a new utility, integrating it in multiple async flows, and ensuring release-on-error semantics. Existing concurrency specs are skipped (`github-sync-state.service.spec.ts:610-640`), so new stress tests plus regression coverage are needed. The work touches core persistence code and shared utilities, raising risk of regressions and making the effort high."
		},
		{
			"taskId": 19,
			"taskTitle": "Move CLI Business Logic to tm-core for Architecture Compliance",
			"complexityScore": 6,
			"recommendedSubtasks": 4,
			"expansionPrompt": "Break down subtasks for creating/exporting a `GitHubValidationService`, extending `GitHubConfigService` with feature helpers, refactoring CLI commands to call tm-core while preserving CLI-specific messaging, and updating/adding unit tests for both layers.",
			"reasoning": "CLI-side validation lives in `apps/cli/src/commands/github/sync.command.ts:205-232` and feature parsing sits in `configure.command.ts:545-570`, while tm-core already hosts GitHub config services (`packages/tm-core/src/modules/integration/services/github-config.service.ts:30`). Migrating this logic requires introducing a new service in tm-core, wiring it through `IntegrationDomain` and the module exports, and adapting the CLI to depend on the shared methods without breaking existing error formatting. New tests must cover the freshly added tm-core APIs and the refactored CLI flows. The refactor spans both packages but uses straightforward patterns, yielding medium complexity."
		},
		{
			"taskId": 20,
			"taskTitle": "Add validation to convertToConflictInfo method in IntegrationDomain",
			"complexityScore": 5,
			"recommendedSubtasks": 3,
			"expansionPrompt": "Create subtasks that introduce strict input validation inside `convertToConflictInfo`, ensure exhaustive type mapping with descriptive errors, and expand the integration-domain test suite to cover all valid/invalid conflict scenarios.",
			"reasoning": "`convertToConflictInfo` currently trusts unvalidated fields (`packages/tm-core/src/modules/integration/integration-domain.ts:354-416`) and falls back to `'title'` when a conflict type is missing (`integration-domain.ts:369`). Adding guards for `taskId`, `issueNumber`, conflict type coverage, and required values will change control flow and error behavior. Comprehensive unit tests must confirm each failure mode and re-run the conflict resolution path. Although localized, the method feeds critical sync resolution logic, so tightening validation with tests demands careful updates, giving moderate complexity."
		},
		{
			"taskId": 21,
			"taskTitle": "Enhance type safety with readonly modifiers and branded types",
			"complexityScore": 9,
			"recommendedSubtasks": 7,
			"expansionPrompt": "Plan subtasks that phase in readonly GitHub types, introduce branded ID utilities, update all call sites (including workflow/state machine types) with appropriate conversions, add discriminated union helpers, and refresh affected unit/integration tests plus build configuration.",
			"reasoning": "Applying `readonly` across GitHub models (`packages/tm-core/src/modules/integration/types/github-types.ts:10-214`) and replacing the legacy `TaskId = string` alias (`packages/tm-core/src/common/types/legacy.ts:9`) with branded types forces widespread recompilation fixesâ€”`taskId`, `issueNumber`, and related IDs appear throughout tasks, storage, workflow, and integration modules. Introducing creation/extraction helpers affects serialization boundaries, while reworking `WorkflowEvent` into discriminated unions (`packages/tm-core/src/modules/workflow/types.ts:44-80`) changes downstream switch statements and guards. This ripples across many files and tests, requiring staged updates and extensive verification, making the task highly complex."
		},
		{
			"taskId": 22,
			"taskTitle": "Create architecture decision records (ADRs) for GitHub sync implementation",
			"complexityScore": 6,
			"recommendedSubtasks": 6,
			"expansionPrompt": "Define subtasks to establish the ADR directory/template, gather supporting references from code and existing docs, draft each numbered ADR with Context/Decision/Consequences sections, and perform a consistency review against implementation status and lessons-learned documents.",
			"reasoning": "Seven ADRs must be authored under `.taskmaster/docs/adrs` (directory not yet present), each documenting specific integration choices referencing concrete code such as services in `packages/tm-core/src/modules/integration/services/` and insights from `GITHUB_SYNC_LESSONS_LEARNED.md`. Crafting context-rich records with accurate references and examples is content-heavy, requiring research across implementation files plus coordination of naming/numbering. While mostly documentation, the breadth of topics and need for precise alignment with code and prior docs give the task moderate complexity."
		}
	]
}